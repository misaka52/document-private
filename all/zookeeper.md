### 简介

解决分布式一致性问题

CAP思想

- C-一致性：保证实例之间的数据一致性
- A-高可用性：保证每次请求都能在指定时间得到正确的响应
- P-分区容错性：分布式系统在遇到部分网络分区出现错误的时候，仍然能够对外提供一致性和高可用性服务

BASE理论

- 基本可用：允许出现部分错误（页面降级，服务降级）
- 软状态：允许分布式系统出现中间状态，指可以出现延时的最终一致性
- 最终一致性：经过一定时间后满足最终一致性

节点类型

- 临时节点：节点创建后一直存在，直到当前会话关闭。临时节点没有子节点
- 永久节点：节点创建后一直存在，除非手动移除
- 顺序节点：对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。该节点可以是临时的也可以是持久的。

### 客户端基本指令

```sh
# 启动zk服务器
zkServer
# 启动zk客户端
sh bin/zkCli
```

#### create

create [-s] [-e] {path} {data} [acl] 创建节点

- -s：表示顺序节点
- -e：表示临时节点。下一次直接进入有缓存，临时节点还在，一会儿就没了
- acl：访问权限相关，默认是world，共享访问

#### ls

ls [-s|-w|-R] {path} 查看指定路径下目录列表

- -s：查看明细信息

```
[zk: localhost:2181(CONNECTED) 30] ls -s /self
[]
# 创建节点事务id
cZxid = 0x3
# 创建时间
ctime = Wed May 12 00:20:37 CST 2021
# 最后修改事务id
mZxid = 0x3
# 最后修改时间
mtime = Wed May 12 00:20:37 CST 2021
# 表示子节点变更的最后事务id，仅当子节点列表个数变化才会变更(不包括孙节点)，子节点内容变化不变
pZxid = 0x3
# 子节点版本号，子节点每次修改加一
cversion = 0
# 数据版本号，数据每次修改加一。比如新增子节点，不包括数据变更
dataVersion = 0
# 权限版本号，权限每次修改加一
aclVersion = 0
# 创建该临时节点的会话id，若为持久节点，则为0
ephemeralOwner = 0x10000f16d040000
# 节点的数据长度
dataLength = 3
# 统计拥有的子节点数量
numChildren = 0
```

#### delete

删除节点

#### stat

查看节点状态信息，类似ls -s

### 消息广播

![](../image/zk-data-stream-async.png)

zk中通过ZAB协议分布式数据一致性

#### 消息广播

节点角色

- leader：领导者，提供写服务。负责投票的发起和决议，更新系统状态
- follower：跟随者，提供读服务。用于接收客户端请求并向客户端返回结果，在投票过程中参与投票
- observer：观察者，提供读服务。可以接收客户端写请求，将请求转发到leader，但不参与投票过程。observer仅同步leader数据，目的是为了扩展系统，提供读性能

**处理流程**：消息装发到leader之后，根据2pc原理，leader向其他follower发送proposal请求锁定资源，等待回应。当半数以上follower回应ack，leader便向所有follower发送commit请求

#### 崩溃恢复

正常情况下zk运行良好，若leader发生崩溃，或因网络原因导致leader与半数follower失去连续，就会进入崩溃恢复模式，选出一个新leader，崩溃有以下情况

- leader发送完commit消息后，立即崩溃
- leader发送完proposal消息后，立即崩溃

恢复策略

- 选举zxid的最大节点作为新leader
- 新leader将事务中未提交的日志重新进行处理

### 选举流程

**参数**

- 服务器ID（myid）：服务器id，唯一，id越大投票时权重越大
- 事务ID（zxid）：值越大表示数据越新
- 偏移时钟（epoch）：同一轮投票时时钟一致，每次投票完成加一

#### 选举流程

1. 当leader不存在（服务器启动时或leader崩溃），开始选举。首先将所有的follower状态改为LOCKING
2. 每个server发送广播消息，呼吁其他server投票
3. 处理投票。参与投票的server收到消息，首先校验投票的有效性（epoch），是否接受来自LOCKING状态的服务器投票，在进行如下判断
   1. 对比epoch（是否为本轮投票）
   2. 投票给最大zxid的server
   3. 若zxid相同，则投票给最大myid的server
4. 统计投票。服务器收到投票后，判断票数是否过半，若过半则确认新leader，若未过半下次继续投票
5. 改变服务器状态。一旦确定了状态，新leader状态改为LEADING，其他follower状态改为FOLLOWING

### 分布式锁实现

https://www.jianshu.com/p/5d12a01018e1

#### 排它锁/非公平锁

利用zk统计节点唯一性，在获取排它锁时，所有客户端调用create()方法，在/exclusive_lock节点下创建临时子节点/exclusive_lock/lock，最终只有一个客户端能创建成功，其他失败的客户端会注册一个子节点变更的watch监听事件，以便锁释放后重试获取

当获取锁的客户端宕机，则session关闭，自动删除临时节点，通知其他客户端获取锁。

#### 共享锁

对某对象添加共享锁后，后续只能对该对象进行读取，也只能添加共享锁

#### 分布式锁实现

Curator直接封装实现

### zk实现分布式锁优缺点

优点

- 非阻塞型，通过监听事件实现监听锁对象释放，可实现客户端宕机自动释放，超时等待
- 一致性强，键值保存需要等待半数以上follower准备成功才能提交，保证了高可用性

缺点

- 非公平锁，可能造成监听回调线程，回调消耗大，发生惊群现象，影响zk集群，可考虑切换公平锁

### 路由注册



## 课程

顺序节点后续添加10位十进制数

zk不适合数据频繁变更的场景：对于变更节点注册watcher，但watcher只能实现监听一次，使用完后需要手动再注册，达到持续监听的作用。但期间可能丢失部分变更

自己注册自己的节点，监听自身的变化 

### 4 ZooKeeper技术内幕

#### 4.1.2 会话

客户端与服务端进行交互，都和会话相关。zk客户端启动时，会与服务端建立一个tcp长连接，会话的生命周期从此开始

**1. 会话状态**

- CONNECTION：连接中，client创建一个连接，需要先创建一个zk对象，用于连接上server
- CONNECTED：已连接，连接成功，各种数据都会初始化到zk对象中
- CLOSED：已关闭，关闭连接后，zk对象会被删除

每次建立连接时，都会将服务端机器列表打乱，连接其中第一个机器

**2. 会话连接**

会话连接后产生一个sessionId分配给客户端，当发生连接异常，网络重连时，连接的目标服务器可能发生改变，但sessionId不变 

- 连接丢失
- 会话转移：当会话丢失后重连，连上zk后，sessionId仍然存在
- 会话失效：当会话丢失后重连，连接zk后，sessionId不存在

**3. 会话超时管理-服务端维护**

服务端为每一个客户端会话都记录这上一次交互后空闲的时长，以及上一次交互结束开始交互的超时时间点。一旦空闲时长超时，服务端就会将该sessionId清除。服务端采用分桶策略管理会话超时

**A 分桶策略**

分桶策略指的是将空闲超时时间相近的会话放入到同一个会话桶中管理，以减少管理的复杂度。在检查超时时，仍在桶中的会话即超时会话，没有超时的会话会自动换桶

zk对应空闲超时时间并非精确控制，精确度取决于会话桶的区间

会话超时：每个会话都会计算对应的超时时间，根据超时时间定位到对应的会话桶（会话桶为相同间隔的区间）；会话定时向zk发送心跳，且每次计算新的超时时间，进行重新计算会话桶并换桶，保证有效会话在不断地往后转移桶；

会话桶过期：会话桶定时过期，过期时仍在桶中的会话视为过期会话，需要清除

**B 分桶依据**

ExpirationTime = CurrentTime + SessionTimeout

BucketTime = (ExpirationTime / ExpirationInterval + 1) * ExpirationInterval

### 5 典型应用场景

#### 5.1 配置维护

通过动态维护配置，可支持配置变更回调，保证各个客户端的一致性，目前每个节点最大存储1M数据（可通过修改zk配置调整）

zk通过发布/订阅模型实现配置文件的管理与维护，监听机制只能使用一次，若需要持续监听则需要在监听回调后再次创建watcher，但可能丢失部分watcher，所以zk不适用于变化非常频繁的配置维护

#### 5.2 命名服务

指在一定范围内的元素具有唯一表示，可通过zk的顺序节点实现

#### 5.3 集群管理

##### 5.3.1 基本原理

通过zk的临时节点和节点变更回调来维护集群节点的状态，首先创建管理节点/manager，然后节点下创建多个临时节点，每台主机对应一个临时节点。监控系统通过监听/manager节点来感知主机的状态

##### 5.3.2 分布式日志收集系统

**系统组成**

分布式日志收集系统组成：日志源集群、日志收集集群、zk集群、监控系统

![image-20210529171328419](/Users/ysc/Library/Application Support/typora-user-images/image-20210529171328419.png)

**系统工作原理**

![image-20210529172053957](/Users/ysc/Library/Application Support/typora-user-images/image-20210529172053957.png)

1. 收集器的注册：在zk集群上创建各个收集器对应的节点
2. 任务分配：系统根据收集器的个数，将所有日志源主机分组，分配给各个收集器
3. 状态收集
   1. 日志源主机状态：通过创建临时节点监控
   2. 收集器的运行状态：收集器节点下创建临时节点监听自身，当收集器挂掉，其对应的日志源主机需分配给其他收集器
4. 任务再分配：当出现收集器挂掉或扩容时，需要进行动态分配日志源主机

#### 5.4 DNS服务

通过zk实现域名与ip的映射关系的动态维护

> 域名对应 ip+端口

![image-20210529173823800](/Users/ysc/Library/Application Support/typora-user-images/image-20210529173823800.png)

每个主机对应一个临时节点，监控系统监听父节点

#### 5.5 Master选举

一般情况下每个集群只有一个master，可通过zk节点命名的唯一性实现master选举

> DBMS也具有主键唯一性，理论上也可以实现master选举。但缺点是master宕机后，DBMS无法实现通知slave进行重新选举

选举步骤（类似互斥锁）

1. 多个客户端节点同时发起创建临时节点的请求，最终只有一个能创建成功，其他客户端等待目标节点变更后回调
2. 一旦master宕机，则触发监听回调机制，通知所有slave重新进行竞争创建master，创建成功的就是master

#### 5.6 分布式同步

#### 5.7 分布式锁

##### 5.7.1 读写锁实现

针对指定路径/lock，创建对应的读写临时顺序节点，比如R-00001，W-00002

**读加锁实现**：创建临时顺序节点，获取锁下所有的节点列表，判断若存在比当前节点小的写节点，则加锁失败；注册watcher，监听比当前节点小的写节点的删除事件

**写加锁实现**：创建临时顺序节点，获取锁下所有的节点列表，判断若存在比当前节点小的任意节点，则加锁失败；注册watcher，监听比当前节点小的任意节点的删除事件

**监听事件实现**：无论是读写锁，都需要判断是否满足当前加锁条件，若满足则加锁成功，否则注册新watcher

**锁释放**：当操作完成后，连接关闭，临时节点被删除，触发watcher

##### 5.7.2 非公平排他锁实现

创建唯一节点/lock/key1，如创建成功则获取锁；其他客户端请求注册该节点删除事件的watcher；当锁释放后，唤醒其他写节点，重新创建争夺锁

##### 5.7.3 公平锁排它锁实现

非公平锁下可能造大量的客户端监听同一个key，当key删除时会造成大量的回调，对zk集群十分不利，因此引入公平锁

1. 客户端在同一目录下创建临时顺序节点
2. 创建成功后，获得顺序节点列表中所有节点，判断自身是否为第一个节点
3. 若为第一个节点，则获取锁成功；若非第一个节点，则通过watch机制监听上一个顺序节点，等待其释放锁通知自己

> 当监听一个不存在的路径节点是，返回null，之后可获得一个删除事件
>
> WatchedEvent state:SyncConnected type:NodeDeleted path:/perm/tmp1/node0000000011
>
> 节点数据更新事件
>
> WatchedEvent state:SyncConnected type:NodeDataChanged path:/perm/tmp1
>
> 注：get {path} -w 只能获得一次监听回调

zk实现的分布式为CP，redis实现的分布式锁为AP

#### 5.8 分布式队列

##### 5.8.1 FIFO队列

通过顺序节点的特性，当一个节点操作完之后，通知一下节点，以实现顺序消费

##### 5.8.2 分布式屏障Barrier队列

设置barrier屏障节点，当节点下子节点个数到达阈值后才能触发某事件



## 7. ZooKeeper技术内幕

### 7.6 leader选举

投票变更

![image-20210530201046497](/Users/ysc/Library/Application Support/typora-user-images/image-20210530201046497.png)

1. 每个server都会发出一个投票。初始状态下服务器都坚持投票给自己
2. 接收各个服务器的投票。当接收到其他服务器的投票时，会对比所有的投票和自己的投票，若存在ZXID或myid比自己更大的服务器，则更新自己的投票
3. 统计投票，统计服务器所有投票，判断投票过半的机器
4. 改变服务器状态

术语

- SID：服务器ID，用于表示唯一一台机器，和myid一致
- ZXID：事务ID，用于表示一次服务器状态的变更
- Quorum：过半机器数，选举时超过过半投票则选定leader

**第一次投票**：每个服务器都会投票给自己

**变更投票**：选择ZXID和myid更大的服务器，更新投票
