## 11 多级缓存

### 11.1 多级缓存介绍

1. 应用接入访问Nginx，进行负载均衡
2. Nginx读取本地缓存（Lua Shared Dict、Local Redis实现），若存在直接返回，否则进入下一步。用于应对热点数据
3. 查询分布式缓存（如Redis缓存，读集群）。减少访问回源数据
4. 可选，查询分布式缓存主Redis，防止从Redis未及时同步
5. 查询Tomcat堆缓存。避免缓存崩溃的之后的冲击
6. 当所有缓存都未命中，查询DB。数据保存到Tomcat堆缓存、分布式缓存、Nginx缓存中

主要分为：Nginx缓存、分布式缓存、Tomcat堆缓存

### 11.2 如何缓存数据

sql执行>提交事务>更新缓存

维度化缓存和增量缓存：缓存尽量设计的小一点，分为多个维度，在更新时可以更新更少的缓存。可以通过Hash，set等结构或key拆分实现

大value缓存：可以进行压缩和key拆分

热点缓存：可以拆分读写缓存

### 11.3 分布式缓存与应用负载均衡

负载均衡-轮询：请求分配更加均衡，当增加服务器时会使得缓存命中率下降。比如原来10的命中率未90%，增加10台服务器之后变更45%

负载均衡-一致性哈希：相同请求都会转发到同一台机器。增加服务器后缓存命中率几乎不变，但可能因热点数据导致机器负载过高

### 11.4 热点数据与更新缓存

单机全量缓存+主从：回源之后把数据更新到主从Redis集群上，然后通过消息订阅或懒加载的方式更新缓存

分布式缓存+应用本地热点：对于分布式缓存，需要在Nginx+lua应用缓存减少Redis集群的冲击，即先查询本地缓存，再查询Redis缓存，再查询Tomcat缓存

正常采用一致性哈希模式进行负载均衡，当访问突破一定阈值则自动切换为轮询模式。

通过建立热点发现系统来统计热点数据，并推送到Nginx本地缓存

### 11.5 更新缓存与原子性

- 更新完数据库之后发送mq消息，更新缓存
- 监听数据库binlog，更新缓存。可通过canal实现

### 11.6 缓存崩溃与快速恢复

### 11.6.1 取模

针对请求对实例数取模，若其中一个实例挂了，导致导量缓存未命中。可通过主从切换保证高可用

#### 11.6.2 一致性哈希

#### 11.6.3 快速恢复

主从机制

通过work进行缓存预热，或者缓存崩溃后的恢复

