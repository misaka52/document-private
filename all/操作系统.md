### 僵尸进程和孤儿进程

僵尸进程：在linux系统中，用户线程执行完毕，会流程一个僵尸进程（Zombie）的数据结构，保存该进程的进程的进程号、退出码、退出状态、使用的cpu等信息，然后给父进程发送sigchld信号通知其回收。当父进程未调用wait/waitpid方法回收僵尸进程的话，僵尸进程就一直存在，占据一个进程资源。僵尸进程会占领进程资源，若一直未回收可能到导致进程占满，无法创建新进程，系统不可用

孤儿进程：当父进程结束，其仍在运行的子进程就会成为孤儿进程。这些孤儿进程最后会被init线程（系统线程）接管，孤儿进程运行结束后回收。孤儿线程不会对系统造成危害

如何解决僵尸进程未回收的问题：

1. 父进程收到子进程的sigchld信号后，调用wait/waitpid方法回收僵尸进程，此时会阻塞父进程
2. 若父进程很忙，可以创建handler来承接处理信号，handler中调用wait/waitpid方法回收僵尸进程。父进程收到sigchld信号后执行handler
3. 父进程显示表示对子进程的结束不感兴趣，子进程就是后就会主动释放僵尸进程，不同步父进程。父进程可以通过signal(SIGCLD, SIG_IGN)或signal(SIGCHLD, SIG_IGN)通知内核，自己对子进程的结束不感兴趣
4. fork两次：父进程fork一个子进程后继续工作；子进程fork一个孙进程后退出，孙进程就成了孤儿进程，被init进程接管，最后结束被回收。不过子进程的回收还是需要父进程自己完成



面试题

- tcp端口类型为unsigned short，最大为65536，可以配置。0为特殊端口不能使用，最多使用65535个端口号

### 用户态和内核态

https://www.cnblogs.com/jiading/articles/12247594.html

对于32位操作系统而言，寻址空间分为4G（2的32次方），内核空间占1G（从0xC0000000到0xFFFFFFFF）；用户空间占3G（从0x00000000到0xFFFFFFFF），供各个用户使用

内核态：cpu可以访问内存的数据，包括外围设备，如磁盘、网卡等，cpu可以将自己从一个程序切换到另一个程序

用户态：只能受限地访问内存，切不允许访问外围设备，占用cpu资源的能力被剥夺

> 用户态内核态区分，限制不同程序之间的访问能力，cpu分成的两个权限等级
>
> 当系统执行一个程序时，大部分时间是运行在用户态下的，当需要操作系统协助时会切换到内核态

#### 特权级

对于任何操作系统来说，创建一个进程是核心功能，需要耗费很多资源，比如分配物理内存、父子进程信息拷贝等，需要特定线程去做。这块就有了特权级的概念，cpu分为一共分为四个级别，0-3，0等级最高

用户态特权级最低，为3

#### 用户态到内核态的转化

- 系统调用：用户态进程主动要求切换到内核态，例如fork()
- 异常：执行时遇到不可预知的异常，比如内存缺页异常
- 外围设备的中断：当外围设备完成用户请求的操作后，会向cpu发送中断信号

#### 资源访问

- 用户态无法访问内核态的资源，可以防止黑客的应用程序攻击
- 内核态可以通过特定方式访问用户态资源

### 进程通信方式

- 有名管道和无名管道：无名管道，半双工通信，信息单项传递，只能用于具有亲缘关系的进程间使用。有名管道允许无任何关系的进程使用
- 消息队列：传输大量信息
- 共享内存：交换信息
- 信号：某件事完成的信号标记
- 信号量：控制对资源的并发访问
- 套接字：适用于不同主机间进程的通信

### 概念

#### 文件描述符fd

是一个用于描述一个文件的抽象画概念，非负整数

#### 缓存I/O

又称为标准I/O，操作系统默认操作缓存I/O。linux缓存IO机制中，先将数据拷贝到系统内核的缓冲区中，然后才把缓存中的数据拷贝到应用程序空间

缺点：产生的拷贝次数多，开销大

### IO模式

read操作会经历两个节点

- 等待数据准备
- 将数据从内核中拷贝到进程中

#### 阻塞IO(blocking IO)

用户进程调用revfrom这个系统调用，内核进行数据准备和数据拷贝，都会阻塞

#### 非阻塞IO(no-blocking IO)

通过不阻塞的询问内核是否准备好数据，无论是否准备好都立即返回，用户进程稍后重试。当准备好数据后进入二节点的数据拷贝过程

#### IO多路复用

当用户进程调用select，整个进程会阻塞。内核会监听select负责的socket，一旦任何一个socket数据准备好了，将数据从内核态拷贝到用户进程中

#### 信号驱动IO

#### 异步IO

用户进程发起read操作后，操作系统会立即返回。然后异步等待数据准备完毕和数据拷贝，操作完成后会给用户进程发送一个signal，read操作已完成

### Select poll epoll详解

#### select

select函数监视的文件分为三类：writefds、readfds、expectfds。调用select会阻塞，直到有文件准备就绪，或者超时。select返回后，通过轮询fdset，来获得就绪的描述符

select缺点是单一进程能监视的文件个数优先（默认1024），可通过修改宏定义重新编译内核提高该配置，但select效率会下降

#### poll

poll类似于select，调用poll后也需要通过轮询获得就绪的描述符。但poll没有文件上限，数量过大后效率会降低

#### epoll

epoll通过epoll_ctl()来注册一个文件描述符，一旦某个文件描述符就绪时，内核就会通过回调机制，迅速激活文件描述符，触发描述符回调事件

通过注册回调函数，后续就绪的描述符直接通过回调函数触发事件，无需遍历fdset，所以IO的效率不会随着文件的增多而下降。且epoll监视的描述符不受限制

## 基本指令

### du

查看当前磁盘目录大小

- -s：summary，总结
- -h：以高可读性的方式进行展示，比如1M，1G

```sh
# 查看当前目录下文件汇总
du -sh .
# 查看当前目录文件大小
du -h --max-depth=1 .
```

### top

```sh
# 查看进行信息
top 
# 显示进程完整命令
top -c 
# 每个一秒生成一批信息，而非实时更新
top -b
# 标识更新次数。默认无限次
top -n 2
# 标识每个n秒更新一次，默认应该是3秒
top -d 2
# 显示进程下所有线程信息
top -Hp 6

```

```
top - 13:33:59 up 192 days, 19:14,  0 users,  load average: 0.08, 0.13, 0.18
Tasks:   4 total,   1 running,   3 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.3 us,  0.4 sy,  0.0 ni, 98.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 65809288 total,  5798768 free, 21264484 used, 38746036 buff/cache
KiB Swap:        0 total,        0 free,        0 used. 40317156 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                                      
    6 root      20   0    9.8g   1.4g  14468 S   0.7  2.2   7:53.15 java                                                                                                                                         
    1 root      20   0    4372    380    280 S   0.0  0.0   0:01.02 tini                                                                                                                                         
 1838 root      20   0   13568   2032   1496 S   0.0  0.0   0:00.01 sh                                                                                                                                           
 1882 root      20   0   57784   2100   1540 R   0.0  0.0   0:00.00 top

VIRT：Virtual Memory 虚拟内存
RES：Resident Memory 驻留内存。即物理内存，实际使用数
SHR：Shared Memory 共享内存
```

