## Redis

1. 数据结构
   1. sds：包含字段、自动扩容机制、字符串缩短不降低大小扩容
   2. 链表
   3. 字典：保存键值对。两个hash表以完成hash；渐进式hash；链地址法解决hash冲突（新节点在头部）
   4. 跳表：平均logN查询
      1. 节点属性：level，span，score，obj对象指针，后退指针
   5. 整数集合：有序无重复，支持自动升级不能降级，添加元素O(N)
   6. 压缩列表：单节点属性（前一节点大小1或5字节，编码，数据）；连锁更新，平均复杂度O(N)
      1. 节点属性：前一节点大小（1字节或5字节）、编码（保存字符类型和字符长度）、content（节点内容）
2. 对象类型
   1. 字符串：int、embstr、raw
   2. 链表：ziplist、linkedList
   3. 哈希表：ziplist、hashtable
   4. 集合：intset、hashtable
   5. 有序集合：ziplist、skiplist
3. 共享内存。int整数缓存
4. 空转时间lru；剩余过期时间ttl
5. 多数据库
6. 过期键删除策略
7. rdb持久化
8. aof持久化
9. io多路复用
10. 主从复制：首次复制和增量复制
11. 哨兵机制：监听机制（获取主从info信息、订阅消息获取其他哨兵信息、观察上线状态）；主观下线；客观下线；选举领头哨兵；故障迁移
12. 集群模式：槽分片和槽分配；节点间通信；moved错误；重新分票；ASK错误；故障检测；故障转移；新主节点的选举；
13. 事务：multi，discard，exec。分为预发错误和逻辑错误
14. 乐观锁：watch
15. lua脚本
16. 其他结构
    1. bitmap：用于统计访问数量，签到日
    2. hyperloglog：统一数量
    3. geospatial：计算经纬度，距离
    4. stream：可用作内存mq
17. pipeline：指令批处理
18. 调优
    1. 设置最大内存，内存淘汰策略
    2. 设置键的过期值，防止死锁
    3. 计算键值大小，可达到成最大化内存减半的效果
    4. 慢查询日志记录
    5. 禁止pattern通配查询
    6. 选择更小的编码结构
    7. 使用惰性删除
    8. 使用pipeline
    9. 避免大批量键同时过期
    10. 集群高可用
    11. 检查数据持久化
19. 布隆过滤器

## mysql总结

### 1.系统架构

1. 表空间分为段、区、页(innodb管理磁盘的最小单位，默认16K)、行
2. 后台线程：master thread、io thread、purge thread、page cleaner thread
3. 内存：缓冲池（数据页、索引页、插入缓冲、哈希索引、数据字典）、重做日志缓冲、额外缓冲池（如锁、LRU、等待等信息）
4. checkpoint技术：将缓冲池中的脏页刷新到磁盘中。四个时机：master定时刷新、lru淘汰脏页刷新、重做日志不够用刷新、脏页过多刷新
5. double write：防止部分写失效，数据写完一部分系统宕机，无法通过redolog重做。通过double write保存一份表备份
6. 自适应哈希索引：对热点等值查询建立哈希索引，查询更快
7. 异步io、刷新邻接页
8. 文件：错误日志文件、慢查询日志文件、二进制日志文件、通用查询日志文件
9. 二进制日志：记录数据库更改的所有操作，分为ROW、statement、mixed三种日志格式。每进行N次事务提交就将二进制缓冲刷新到二进制日志中
10. 重做日志：减少磁盘IO，不必使每次事务提交都将数据刷新到磁盘，只需要刷新到重做日志即可，若数据库宕机丢失了部分缓冲中的数据，可以通过重做日志恢复。重做日志默认在每次事务提交都刷新到重做日志文件。`ib_logfile0`
11. 二进制日志和重做日志区别：二进制日志是mysql级别的，保存逻辑日志，仅在事务提交前保存。重做日志时innodb引擎的，保存页的物理日志，可以在事务过程的多个时机保存
12. innodb与myisam区别

### 2. 索引

1. 聚簇索引和非聚簇索引：数据和索引是否存在同一个文件来区分
2. 主键索引和辅助索引：innodb中键索引叶子节点保存值和数据行，辅助索引保存索引值和主键值
3. 组合索引：最左匹配法，遇到范围查询时索引匹配中断。5.7新增索引条件下推，可以范围查询后继续匹配后续索引
4. 覆盖索引：仅需通过索引而无需查询数据表（回表查询）即可完成查询，比如辅助索引和主键索引
5. 全文索引：每个表只能存在一个全文索引。倒排索引：根据关键词查找文档，逆向查找
6. 索引失效情况：不符合最左前缀匹配、使用in和or可能失效、使用算数表达式失效、列格式转换索引失效、使用不等号索引失效、like以通配符后续部分索引失效
7. 查询优化：查询频率高的字段可建立组合索引以命中覆盖索引；order by，group by，where高频字段，连表查询建立索引；

### 3. 锁

1. 数据库级锁
2. 表级锁：共享锁、排它锁、意向锁，元数据锁（当进行查询时添加元数据锁，无法修改表结构），自增锁
3. 行级锁：共享锁、排他索引、意向锁、插入意向锁。都是锁的索引
4. 当前读（一致性的锁定读）和快照读（一致性的非锁定读）
5. 自增长锁：控制主键自增的锁，保证唯一性。0-互斥控制，不重复不多余；1-互斥量控制，默认，但insert..like这种插入前不能确定数量的sql仍采用自增锁互斥控制，不重复但可能产生不连续的id，一部分id数据为成功插入；2-都通过互斥量控制，性能最高可能产生重复id
6. 按照锁的锁定范围区分：记录锁、间隙锁、临键锁
7. 主键索引产生锁时、辅助索引产生锁时、非索引字段产生锁（表锁）
8. 死锁：保持申请、循环等待、不可剥夺、资源独占
9. 锁升级：行记录锁可能会升级成表级锁。当一个sql对一个对象持有锁的数量超过5000或锁资源占用过多
10. 死锁：资源独占、保持申请、循环等待、不可剥夺
11. mysql会主动探知死锁，回滚较小的事务
12. 如何避免死锁：避免交叉事务；保证事务的轻量性；提高运行速度

### 4. 事务

1. 事务四大特性ACID
2. 事务的实现：锁实现隔离性，redo实现原子性和持久性，undo实现一致性
3. redo从缓冲刷新到磁盘的刷新策略：1-默认每次事务提交都刷新到磁盘。redolog刷新到磁盘的触发时机还有logbuffer不够用时，或进行checkpoint时
4. undo log：当数据库宕机恢复时可用来恢复事务，决定事务回滚或提交
5. undo分为insert undo 和update undo，其回收时机不同
6. purge回收无用的undo
7. DDL隐式提交，不受事务控制
8. 事务隔离级别：RU、RC、RR、Serialiable。解决脏读、不可重复读、幻读问题
9. 分布式事务，xa事务
10. MVCC机制：多版本并发控制，通过不加锁实现一致性读，并发率高。依赖记录隐藏字段、ReadView、undo log实现。MVCC只适用于快照读，不适用于当前读
11. 记录隐藏字段：事务id，回滚指针，隐藏主键
12. ReadView：记录当前活跃事务，控制事务可见性。tx_ids：记录当前活跃事务id；up_limit_id：活跃事务中最小id；low_limit_id：当前最大事务id+1。RC在每条select前生成ReadView，RR在第一条select前生成ReadView。

### 5. sql优化

1. 慢查询：记录慢查询日志。慢查询日志分析工具mysqldumpslow
2. explain分析sql执行情况：key-实际命中的索引；key-len：索引长度（varchar在此处会影响索引长度）；type：all全表扫描；Extra：using where-未命中索引，using filesort-无法单独使用一个索引完成的排序
3. sql优化：多字段查询时尽量创建组合索引；符合组合索引最左匹配法则；尽量命中覆盖索引；索引尽可能小；只能在不重复率高的字段上建立索引；order by，group by和连表时尽量创建索引；连表时小表驱动大表；注意索引失效
4. limit优化：尽量限定limit个数
5. profile分析sql语句全流程耗时，包括开始耗时，准备耗时，所耗时，数据传输耗时等
6. 服务器层面优化：缓冲池尽可能大，关闭无用的日志

### 6. 备份与恢复

1. 热备（运行时备份，不影响数据库）、冷备、温备（运行时备份，可能影响数据库）
2. 主从复制：master将变更数据保存到binlog文件中，slave通过同步master的binlog文件来进行数据同步。从服务器获取binlog文件后，先同步到自己的relay-log文件中，再同步到自己的数据库
3. 通过mysqlbinlog查看binlog日志

### 7. 分库分表

1. 建议单表超过500W行记录或大小超过2G就开始分库分表
2. 垂直拆分：按照业务字段分为多个小表；水平拆分：行数据拆分，各个表字段一致
3. 分库分表范围划分分表：优点：能快速定位表；单表数量可控；扩容时只需要增加节点，无需修改元数据；缺点：各表数据划分不均匀，部分表可能数据量较大，查询和更新压力较大
4. 根据hash取模分片：优点：各表数据划分均匀；前期分片规则固定，表数量固定；缺点：扩容时麻烦，需要修改分片规则，同时要对历史数据进行重新分片
5. sharding jdbc：支持主从复制，分库分表。当条件中不存在分片键是会进行广播路由，对所有表执行sql

## Jvm

### 1. java内存区域

1. 运行时数据区域：程序计数器、java虚拟机栈、本地方法栈、堆、方法区（常量池）
2. 对象内存布局：对象头（mark word+类型指针）、实例数据、对齐内存（补齐为8字节的倍数）
3. 对象的访问定位方式：句柄访问、直接指针访问
4. 内存溢出：java堆溢出、虚拟机栈溢出、方法区溢出

### 2. 垃圾收集器

1. 垃圾回收器：回收哪些内存、何时回收、如何回收
2. 对象存活分析：引用计数法、可达性分析（GC root节点）
3. 引用：强引用，软引用，弱引用，虚引用
4. finalize函数
5. 垃圾回收算法：标记-清除、复制算法、标记整理、分代收集
6. Hotspot实现细节：根节点枚举、安全点（抢先式中断和主动式中断）、安全区域、记忆集和卡表、写屏障、并发的可达性分析
7. 常用垃圾收集器：serial、ParNew、parallel scavenge（可控制吞吐量）、Serial old、paralle old、CMS、G1
8. CMS：老年代收集器；四大步骤；增量更新；对cpu敏感；产生浮动垃圾，回收失败导致full gc；产生空间碎片；remark前可以先young gc
9. G1：全功能垃圾收集器，可预测停顿时间；将内存分为多个相同大小的region，每个region可分为Eden、survivor、老年代、大对象；每个region需要保存一份记忆集；TAMS指针记录新分配对象
10. 低延迟垃圾收集器：shenandoah（jdk12+，采用全局的记忆矩阵维护记忆集）、ZGC（jdk11+，分为多种大小的region，仍处于实验中不稳定）
11. 内存分配和回收策略：对象优先分配到Eden区；大对象进入老年代；长期存活对象进入老年代；动态年龄判断；空间分配担保

### 3. 类文件结构

1. 类文件结构：魔数（标记是否为jvm可接受的class文件）、主次版本号、常量池、访问标志、字段表集合、方法标记和、属性表集合
2. 常量池：保存字面量（如java中的常量）和符号引用（表示字段、方法、接口的名称和类型）
3. 加载和存储：iload，istore，ipush，ldc，iconst
4. 类型转换：小范围到大范围类型直接转换，大范围到小范围类型（窄化）的需要显示转换

### 4. 虚拟机加载机制

1. 类加载时机：调用new，static等方法；当子类初始化时需先初始化父类；spring启动程序初始化；通过反射调用；虚拟机启动主类；存在default方法的接口实现类且实现类包含default方法初始化时，需要先加载父类接口
2. 类加载过程：加载、验证、准备、解析、初始化、使用卸载
3. 加载：将类加载到虚拟机中
4. 验证：文件类型、元数据、字节码、符号引用等验证
5. 准备：为类分配内存并设置类属性初始值
6. 解析：将常量池中符号引用替换成直接引用。类和接口的解析、字段的解析、类方法解析、判断访问权限、
7. 初始化：触发类中的变量赋值操作和静态代码块
8. 类加载器：启动类加载器->扩展类加载器->应用类加载器->自定义类加载器
9. 双亲委派机制：当调用类加载方法时，首先调用父类加载器去加载，若加载失败才会尝试自己加载
10. 破坏双亲委派机制：JDCI服务，父类通过子类加载器加载；为热部署使用自定义加载器加载

### 5. 虚拟机字节码与执行引擎

1. java方法在执行时就会创建一个栈帧，编译时就确定了分配的内存大小，不会在运行时改变
2. 虚拟机栈运行时战帧结构：局部变量表，操作数栈，动态链接，返回地址，附加信息
3. 方法调用：确定方法版本
4. 解析：在类加载阶段将方法符号引用转换为直接引用，主要是静态方法和私有方法
5. 静态分派：编译期间确定分派方法。如重载时分派
6. 动态分派：运行期间才能确定分派方法，如重写时分派

### 6. java内存模型

1. 主内存与工作内存
2. 主内存与工作内存交换变量的方式，通过8中命令控制：lock，unlock，read，load，use，assign，store，write
3. 内存交换read和load，store和write成对出现；assign操作后更新到主内存；同步到主内存前必须触发assign命名；新变量必须在主内存中初始化；lock与unlock；lock的可冲入性；unlock变量之前需要先把变量同步到主内存中；lock会清空工作变量的值，需要重新load或assign
4. volatile：第一保证volatile修饰的变量对所有线程的可见性；第二禁止指令的重排序优化
5. long和double可分为两次32位操作，但不会触发非原子操作问题
6. 原子性、可见性（final修饰的变量对象在初始化完成之前无法被引用）、有序性
7. java线程调度：协同式调度（线程本身控制，主动结束），抢占式调度（操作系统控制）
8. 内核调度的主要消耗在核心态到用户态的切换，而切换主要消耗在响应中断、保护和恢复现场

### 7. 线程安全与锁优化

1. 线程安全定义
2. 操作共享数据的类型：不可变、绝对线程安全、相对线程安全、线程兼容、线程对立
3. 线程安全的实现方法：互斥同步、非阻塞同步（CAS）、无同步方案
4. 锁优化：自旋锁（空转等待获取锁）、锁消除（消除无用的锁）、锁粗化（合并一些列加锁操作）、轻量级锁（CAS获取锁消除同步的互斥量）、偏向锁（消除同步块）

## 并发编程的艺术

### 1. java底层实现&内存模型

1. 主内存与本地内存
2. 指令重排序：编译器重排序，指令重排序，内存系统的重排序
3. 顺序一致性模型：完全按照编码的顺序执行
4. volatile：读操作使本地缓存失效读取主内存，写操作将刷新到主内存；重排序：volatile操作之间不能重排序；第一个为volatile读无法与其他操作重排序；第二个为volatile写无法与其他操作重排序。内存屏障
5. 锁内存的定义：获取锁使本地内存失效，释放锁将本地内存刷新到主内存
6. happens-before关系：保证前一个操作的结果一定对后一个操作可见；不能保证两个操作的真正执行顺序
7. 双重锁检查和延迟初始化（类初始化锁）
8. JMM内存模型（即存在共享主内存，和线程私有的本地缓存）
9. 重排序（编译器优化的重排序、指令的重排序、内存系统的重排序）
10. final域内存语义
11. Thread(start, run, sleep, wait, yield, join)及五种状态
12. wait,notify,notifyAll
13. 线程池：核心线程数，队列（数组有界队列、无界链表队列、阻塞队列），最大线程数，线程活动时间（即空闲后最大存活时间），拒绝策略
14. 线程池任务类型（IO密集型，CPU密集型）
15. Executor接口，ExecutorService接口，ThreadPoolExecutor线程池实现类，Runnable和Callable接口
16. FixedThreadPool，SingleThreadPool，CachedThreadPool，ScheduleThreadPool

### 2. 并发工具

1. ReentrantLock，WriteReadLock，StampedLock
2. notify，Condition
3. CountDownLatch，CyclicBarrier，Semaphore，Exchanger
4. juc：ConcurrentHashMap(jdk1.7和jdk1.8)，CopyOnWriteArrayList，ConcurrentLinkedQueue(CAS)
5. 线程安全类：HashTable(java.util, synchronized all)，Vector(java.util, synchronized all)， StringBuffer(java.lang，synchronized all)
6. ForkJoin
7. sun.misc.Unsafe: 原子操作类，compareAndSwapObject
8. 原子类：AtomicInteger，AtomicReference，AtomicStampedReference

## rocketmq

### 1. nameserver

1. 实现简单，节点间不通信，单节点保存所有broker信息
2. 路由元信息（topic路由队列信息、broker基础信息、broker集群信息、broker状态信息）
3. 路由注册、路由删除（不通知producer，其自动感知）、路由发现

### 2. producer

1. 消息类型：同步消息、异步消息、单向消息
2. 生产者clientId={clientIp}@{instanceName}[@unitName]，根据clientId分配队列
3. 发送消息：消息检验、获取topic路由信息、选择消息队列、发送消息
4. 故障延迟机制
5. 批量消息发送（不支持延迟消息、每个批次最大1M，批次消息topic一致）

### 3. 消息存储

1. 存储文件：commitlog，consumequeue，index文件，checkpoint，abort
2. 消息存储：若消息延迟等级大于0，产生定时消息，根据延迟等级保存到相应队列中
3. MapperFile对应一个ConsumeQueue文件
4. 文件过期清理机制：清理过期72小时的文件（按照文件最后更新时间算）
5. MsgId(16B) = ip(4B)+port(4B)+offset(8B)，查询消息效率最高
6. CommitLog记录：消息前4字节存储消息大小
7. 根据消息偏移量查询消息：首先定位commitlog文件；再定位偏移量差定位消息起始位置；消息前四字节为消息大小
8. ConsumeQueue：消息队列索引文件，按照topic和队列保存消息。单个消息体=offset(8B)+size(4B)+tag hashcode(8B)，每个消息20字节，每个consumeQueue固定30万条消息
9. ConsumeQueue消息逻辑偏移量，即在文件中的消息逻辑顺序位置，从一开始。
10. ConsumeQueue消息查询：根据逻辑偏移量查询；根据时间戳查询
11. IndexFile：msg key索引文件。header+槽（4B\*500W）+索引条目（20*2000W，条目包含msg key、消息偏移量、与第一条消息时间存储差、上一条目位置）
12. abort文件：判断broker是否正常关闭
13. checkpoint文件：文件刷盘时间点
14. 文件固定大小的好处：文件命名有规律，查询数据方便

### 4. 消息消费

1. 集群模式和广播模式
2. 消费者启动：消息订阅（主动订阅的消息、消费者组重试消息）；初始化instance和rebalance信息等；
3. consumerFromWhere：查询到历史偏移量则按照历史开始消费；查询不到按照配置默认选择消费点；
4. CONSUMER_FROM_LAST_OFFSET(新消费者从队列最大偏移量开始消费，若为新topic则从头开始消费), CONSUMER_FROM_FIRST_OFFSET(新消费者从队列最小偏移量开始消费)
5. push消费：通过循环拉取的机制。默认每次拉取完都立即进行下一次拉取（立即将任务放入任务队列中）
6. 负载均衡：RebalanceService每隔20s向对所有主题的消费者和队列进行重新分配
7. 消息拉取消费过程：每个消费者客户端循环从任务队列中拉取任务，从broker端查询消息，返回给消费者；当消费失败时，将消息保存到重试消息队列中（%RETRY%{consumeGroup}，消费者自动订阅本组重试消息），设置延迟级别，先保存为定时消息后续延迟获取消费
8. 消费进度管理：广播模式保存在本地；集群模式保存到broker端；保存consumequeue文件逻辑偏移量
9. 定时消息：消息按照延迟等级选择队列保存在定时消息中，每个定时消息队列都有一个任务负责拉取任务。当执行任务拉取到定时消息时，判断消息执行或延迟，若执行直接将消息topic和queueId还原，发送到对应的消息队列中，保存到commitlog，等待消费者拉取
10. 事务消息：发送prepare消息；执行本地事务；事务提交则删除prepare消息，还原原消息发送；事务回滚则删除prepare消息；系统定时（每一分钟一次）查询prepare消息，回查事务状态，决定提交或回滚，最大回查15次；prepare消息删除只是把消息转发到另一个消息中存储，记录回滚或提交消息

## spring

1. 优点：方便解耦，简化开发；提供声明式事务支持；对aop编程的支持；集成各种框架
2. bean标签；bean初始化的三种方式（配置bean标签、静态工厂、实例工厂）
3. @Autowired：通过类型注入；默认不能为空；spring自带；结合@Qualifier实现结合实例查询
4. @Resource：未指定名称或类型时先通过名称查找，未找到再通过类型查找；指定了只能按照指定类型查找；jdk自带
5. @Inject：和@Autowired类型，结合@Name实现根据名称查找；jdk自带
6. spring管理类：@Component, @Service, @Controller, @Configuration, @Bean
7. @Import：引入其他配置类
8. @PropertySource：引入配置文件，无法识别yml配置文件
9. AOP：面向切面编程，在不修改的类源码的情况下，增强类的功能。比如性能监控、日志记录、缓存
10. spring aop：基于动态代理实现，分别有jdk动态代理（类必须实现接口）和cglib动态代理（基于目标类生成目标类的子类作为代理类）
11. 通知类型：before，afterReturing，afterThrowing，after，around
12. 事务传播行为：（默认）若外层存在事务则复用外层事务，若外层无事务则新建事务
13. spring源码解析：先解析spring的xml配置文件，生成对应的beanDefinition；创建bean
14. 创建bean：生成bean对象；属性依赖注入（注入所有依赖属性）；bean对象初始化
15. 循环依赖：构造器注入无法解决；域注入spring通过提前暴露对象来解决
16. 构造器注入优势：域不可变；保证域不为空；保证实例的完整性
17. tomcat热加载和热部署
    1. 在web容器中启动一个线程，若发现文件有变化，则重新加载类，不会清空session。可以在tomcat中配置<Context reloadable="true"/> 开启热加载
    2. 在web容器中启动一个线程，若发现war包有变化，则重新加载整个应用，会彻底清空session。比如war文件修改则会删除解压文件，解压新war包

## springmvc

1. MVC：模型、视图、控制器
2. MVC流程：1 前端控制器接收请求；2 调用处理器映射器根据url获取处理器执行链；3 获取处理器适配器，调用处理器前置操作：参数封装、数据类型转换、数据验证等；4 拦截器前置处理；5 处理器处理，获取ModelAndView，返回给前端控制器；6 拦截器后置处理；7 前端控制器调用视图解析器，获得view；8 对view进行渲染（美化渲染，填充数据），返回给客户端
3. 返回值处理：ModelAndView、void、String（视图名、重定向、转发）
4. 跨越：浏览器因为安全问题，配置了同源策略，不允许协议、域名、端口不同的不同的源直接访问。出现在前端调用。
5. 跨越问题解决：绕过AJAX请求；基于jquery的jsonp方式，只支持get请求；基于cors方式，支持get和post等
6. CORS跨越：请求头注入origin，服务端向响应头注入Access-control-allow-origin。分为简单请求和非简单请求（增加OPTION预检请求）
7. 父子容器：Root webApplicationContext容器为Servlet WebApplicationContext的父容器
8. bean初始化：实现initializingBean接口，效率更高；通过反射调用init-method方法初始化

## springboot

1. 事务：配置类增加@EnableTransactionManagement；类或方法上添加@Transactional
2. 拦截器：实现HandlerInterceptor
3. 层级：tomcat-filter-servlet-interceptor-controller
4. 过滤器和拦截器的区别：过滤器是servlet的，拦截所有资源，包括静态资源；拦截器是spring的，拦截所有请求，可以获取bean，基于反射实现
5. start包自动加载：springboot启动类自带注解@SpringBootApplication，内包含注解@EnableAutoConfiguration，注解实现自动扫描所有jar包下META-INF/spring.factories文件，扫描文件中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的所有值，扫描所有AutoConfiguration类，把生效的bean载入到spring容器中

## 设计模式

1. 创建型、行为型、结构性
2. 责任链
## 计算机网络

1. Https加密过程
   1. 参考：https://zhuanlan.zhihu.com/p/43789231
   2. https在http和tcp加了一层ssl/tls 安全传输层，使用https必须要有自己的一套数字证书。https可以对传输加密，防止被第三方窃听；一旦请求被修改，通信双方会立即发现；身份证书：防止身份冒充。加密流程如下
      1. 客户端请求服务器获取证书公钥，客户端（SSL/TCL）解析并验证证书
      2. 客户端生成随机值，用公钥加密获得秘钥，并将秘钥发给服务端
      3. 服务端用私钥解密获得随机值，将信息和随机值混合在一起进行对称加密，将信息发给客户端
      4. 客户端用秘钥解密
   3. 如何验证证书？1.客户端获取了站点证书，得到公钥，找到站点颁发者信息；2.通过站点颁发者验证服务器站点是否可信；3.网上回溯找到根证书颁发者，一步步验证证书是否可信
   4. 如何防止中间者伪造服务器给客户端发送的公钥？数字证书，网站在使用https之前，需要向CA申领数字证书，证书中包含持有者信息、公钥等
   5. 如何防止证书被篡改？通过证书内容生成数字签名，数字签名制作过程：1.CA机构拥有公钥和私钥；2. CA机构对证书内容进行hash；3.对hash后的值使用私有加密，得到数字签名S
   6. 如何校验数字证书和数字签名？1. 拿到证书，获得明文T，数字签名S；2.使用公钥对数字签名S进行解密得到S'；3. 对明文T进行hash得到T'；4. 对比T'是否等于S'，若相等则证书可信
   7. 证书掉包问题？另一网站B也获取了CA机构的证书，然后截取网站A的信息，给他的请求者发送自己的证书信息，如何避免？证书上包含网站的信息，可以通过对比网站信息来判断证书是否被掉包
2. 输入域名的请求流程
   1. 在浏览器中输入url查询，浏览器查询是否存在缓存，判断缓存是否过期。分为两种缓存
      1. 强制缓存
         1. Cache-control：表示浏览器接收文件后，在响应的时间内文件均有效。
         2. expire：绝对时间，表示文件的失效时间。可能存在服务器与客户端时间不一致的问题。优先级低于Cache-control
      2. 对比缓存
         1. last-modified表示第一次请求资源时返回的时间。下次发起请求资源时携带if-modified-since字段，若两字段相等则使用缓存
         2. Etag：资源的实体标识（哈希字符串），当资源内容发生变更，etag会变更。服务器会判断etag是否变更， 若变更则返回新资源，否则返回304
   2. DNS解析URL对应ip。查询浏览器缓存->查询系统缓存（本地hosts文件）->查询路由器缓存->查询ISP DNS解析器缓存->迭代查询（根域名服务器->第二层域名->子域名...）
   3. 根据ip建立TCP连接（三次握手）
   4. http发起请求
   5. 服务器处理器请求，浏览器接收http响应
   6. 渲染页面，构建DOM树。在还没收到完整html文件时，就已经开始渲染了
   7. 断开tcp连接（四次挥手）
3. 线程和进程区别
   1. 进程是操作系统资源分配的基本单位，线程是处理器任务调度和执行的基本单位
   2. 进程中包含多个线程，线程是进程的一部分
   3. 进程有独立的代码的数据空间，程序间切换消耗较大；线程是更轻量的进程，有各自独立的空间，线程切换消耗小
   4. 进程内空间线程共享，线程空间资源独立
4. 进程间通信方式
   1. 管道：有名管道和无名管道
   2. 消息队列
   3. 信号量：对部分资源的并发访问控制
   4. 信号
   5. 共享内存
   6. socket：用于不同机器上进程间通信

## ElasticSearch

1. 分布式全文搜索工具，提供restful接口，能处理PB级数据。采用倒排索引存储

2. 全文检索流程

   1. 创建索引：
      1. 获得原始文档；
      2. 根据文档创建Document
      3. 文档分析，拆分出关键字：根据空格、标点拆分，大小写转换，取出标点，停用词剔除，分词器分割，去重
      4. 创建索引：索引、文档、索引与文档对应关系
   2. 索引检索：调用restful接口查询
      1. match：查询全部
      2. term：关键字查询，查询索引中是否存在关键之
      3. query_string：短语查询，短语会按照分词器分成多个关键词查询，查询结果中score表示匹配程度
      4. multi_match：在多个字段上同时查询短语
      5. bool：多种逻辑组合查询，must，should，must_not，filter
      6. 分词器
         1. standard：es默认的标准分词器，中文直接一个一个字拆分，对中文支持的不好
         2. IK：基于java开发的轻量级中文分词器，支持英文字符、数字、中文词汇（词语、姓名、地理位置等）拆分，支持用户字典扩展定义，但对中英结合支持的不好。分为ik_smart(只能拆分法，最少切分，比如`一个`直接拆分成一个)和ik_max_word（最细粒度拆分，`一个`拆分成一、个、一个）两种模式

3. es与solar对比：es适用于实时搜索应用，仅支持json格式，自带分布式管理。solar适用于传统搜索应用，搜索已存在数据，实时建立索引时会造成io阻塞，通过zk管理

4. 索引范围：index, (type), document, field

   1. index不允许修改
   2. type概念弱化，在es6中只允许创建一种type，在es7不允许创建，系统默认固定为_doc
   3. 索引分片数量不允许修改

5. restful接口：put-创建资源，post-更新资源，get-查询资源，delete-删除资源

6. 工具

   1. Head：es web界面工具，查询索引基本信息
   2. kibana：es web界面工具，支持快速调用restful接口
   3. logstash：日志收集工具
   4. ELK：es+logstash+kibana

7. 集群

   1. 节点类型：master节点、数据节点、协调节点
   2. 索引分片：主分片和副本片。集群状态绿黄红，红为集群下线
   3. 集群选举
      1. 选举时机，选举过程
      2. 脑裂现象：通过控制大于集群一般节点才能进行选举

8. 存储过程

   1. 数据先保存在mermory buffer和translog缓存
   2. mermory buffer每秒同步到file system cache中
   3. file system cache每隔30分钟刷新到磁盘
   4. translog在索引创建、删除、更新都刷新到磁盘中，类似mysql的redolog，保证数据不丢失

9. 集群选择

   1. 单机容量：一般内存64G，jvm内存32G，分片内存30G。分片内存最大建议不超过50G
   2. 分片数量：单机3片效率较高

## kafka

1. 介绍：吞吐量特别高，适用于大数据收集、大数据分析，底层实现为scala，配合zk管理路由信息。因发送消息时先将消息保存在内存中，当内存消息达到一定数量再发送，索引kafka不太适用于一些实时应用
2. 角色介绍
   1. partition：每个topic都有多个分区
   2. partition leader/follower：分区主备，实现高可用。注意时主备关系，备份机器不提供服务
   3. segment：每个分区分成多个大小相等的segment
   4. 代理：负责维护发布数据的系统，一个代理负责一个或多个分区，一个分区只能由一个代理负责
   5. broker controller：负责管理集群partition和relicas的状态，partition leader由它选举出来。broker controller有zk选举
   6. rebalance：当分区数量或消费者发送改变时进行rebalance，此时集群处于不可用状态
   7. __consumer_offset：消费者消息完成提交offset保存在该主题中，该主题默认50个分区， consumer group消费的offse保存在指定分区，hash计算分区。kafka之前保存在zk中
3. hw机制：表示消费者可消费的最大消息偏移量。保存消息时，当leader同步给所有的follower成功后才更新HW
4. 消息发送的可靠机制：ack=0（单向发送，不管成功与否），ack=1（当partition leader落库成功即成功），ack=-1（当partition leader和所有follower保存成功即成功）
5. partition选举范围：false-只能从ISR中选举，true-默认，可选择任意follower成为新leader
6. 重复消息问题
   1. 批量消息消费超时：增加消费超时时间，减小消费批次，手动提交消费偏移量
   2. 不同consumer重复消费：消费者消息消费成功未提交就宕机，导致消费的消息偏移量丢失，这部分消息后续会再次消费
7. 消息写入算法：从连接的broker中获取broker controller地址；获取partition leader地址，向leader发送消息；leader保存消息成功，将消息同步到ISR中的Follower中；follower全部同步成功，返回ack，更新HW；若等待follower的ack超时，则将其从follower移除，在更新HW
8. 消息消费；获取broker controller地址；提交poll请求，请求分配partition leader，分配完之后按照对应partition拉取消息消费；消费成功后保存到__consumer_offset中
9. .log和.index，日志文件和索引文件，记录一一对应


## 设计

1. 设计秒杀系统
2. 设计接口幂等性、消费幂等性
3. 如何保证数据库和缓存的一致性



## bgw

1. IO模型
   1. 阻塞IO。只能对单个文件进行操作，且操作是阻塞的，必须等待操作完成才能进行下一操作
   2. 非阻塞IO
   3. 多路复用。单线程监控多个文件执行IO，三种实现方式select、poll、epoll
   4. 信号驱动IO。利用信号机制，让内核告诉应用程序文件描述符的相关事件
   5. 异步IO。和信号驱动IO差不多，相比多了一步在程序中完成从用户态到内核态的拷贝，异步IO完成拷贝这步后才通知应用程序，使用aio_read、aio_write
2. 熔断。当调用下游服务异常次数超过阈值，则开启熔断器，请求直接失败，避免下游服务影响现有服务
   1. 熔断器状态设置：关闭、开启、半开启。关闭：关闭熔断器，请求直接通过，但存在一个计数器记录成功和失败请求数量；开启：熔断器开启，请求直接走熔断方法，直接返回。当失败率超过阈值，则开启熔断器一段时间。开启熔断器后开启一个计数器，当计时器超时后将熔断器状态改为半开启状态；半开启：允许部分请求通过。开启计数器，记录期间请求成功率，当成功率超过阈值则将熔断器关闭，否则重置计数器，甚至开启熔断器
3. 降级。微服务中调用链长，设置当调用下游服务器超时时，直接走降级策略，加快请求处理
   1. 可以通过注解+aop方式实现。配置主键，超时时间+降级方法，拦截降级方法，将请求放至线程池中处理获得future，然后通过future超时获取结果，当超时时再通过反射调用降级方法
4. 限流。当请求过多超过限定阈值，则进行限流，超过阈值的请求直接失败
   1. 计数限流：通过计数器控制系统的最大并发处理量，当请求来了则减一，处理完毕则加一，可通过Atomic等原子类实现
   2. 固定窗口限流：相比计数限流多了时间窗口，在固定的时间段的设置计数器。当请求次数小于阈值，则处理且计数器加一；当请求次数大于阈值，拒绝；每过一个时间周期，计数器清零。固定窗口限流时间周期时固定，可能出现在一个连续区间内处理两倍的阈值流量
   3. 滑动窗口限流：记录每个请求的到达时间，当处理完毕可删除。流程：当请求过来后，查询前一周期（比如1s内）的请求数量，若为超过阈值则通过且记录请求；当超过阈值则拒绝；请求处理完毕后删除请求记录。该方案虽然保证了任何时间窗口内请求处理数都不会超过阈值，但需要记录请求内存消耗较大，且无法应对突然请求
   4. 漏桶算法：将请求放入桶中，以固定速率获取并处理（获取请求的速率固定，而非处理请求速率固定），当桶装满则直接拒绝新请求，即溢出。请求以规定速率处理，类似于mq消费
   5. 令牌桶算法：以固定速率生产令牌放入桶中，当桶满则丢弃令牌。当请求过来获取一定数量令牌处理，获取到令牌后才能处理请求，当无令牌则拒绝请求。可以用来处理短暂的突发请求，类似于信号量
5. 一致性hash为什么是2的32次方？因为ip地址是32位，正对IP地址做hash方便