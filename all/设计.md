### 设计秒杀系统

https://zhuanlan.zhihu.com/p/41896183

问题考虑

- 分流
- 限流
- 用户防刷机制，分布式锁，部分直接秒杀失败
- 缓存，本地缓存+分布式缓存（mysql、redis、zk）
- 缓存预热，参与秒杀前需要先报名

热点隔离

- 业务隔离，参与秒杀前需要先报名。做好预热
- 系统隔离，将秒杀和正常业务隔离开，比如申请新的域名，打到新集群
- 数据隔离，秒杀使用单独的mysql或redis来存放热点数据，不要影响其他正常业务

动静分离

- 页面分为静态和动态数据，动态数据只有秒杀按钮。将静态页面及数据保存在浏览器中和CDN中
- 动态数据实际有效按钮只有“刷新抢宝”按钮

> CDN：网络加速器，可以使用户请求落到附近的缓存服务器，以快速返回，加快请求处理速率，减少网络阻塞

基于时间片削峰

- 比如增加答题机制，将秒杀的1s峰值，分散到1-10s内，实现流量削峰

数据分层校验

- 先做数据动静分离。将静态数据保存在浏览器和CDN中
- 对读数据不做强一致性校验
- 对写数据基于时间分片（答题）
- 对写请求进行限流保护
- 对写请求做强一致性校验

![img](file:///Users/ysc/IdeaProjects/learning/document-private/image/20160309181830459?lastModify=1618163536)



同一数据高并发读问题

使用缓存，当缓存失效再去数据库拉取。允许产生的一定的脏读（未及时更新），在写时校验强一致性

同一数据高并发更新问题

对于Innodb来说，产生的是行级锁（索引），当遇到高并发更新时，吞吐量也会受到影响

- 对应用做排队，按照商品维度对设置队列顺序执行，较少对同一数据的并发修改，同时也能控制数据库连接数量
- 数据库层做排队

![img](file:///Users/ysc/IdeaProjects/learning/document-private/image/p3188.png?lastModify=1618163536)

总结

- 业务隔离（提前报名），数据隔离，系统隔离
- 多机分流，限流，用户防刷
- 动静分离，静态数据保存在浏览器和CDN中
- 动态数据读取redis读写分离（读多写少集群），不通过直接返回
- 信息验证，确认订单，更新至redis主从版中，通过lua脚本保证多个操作的事务性
- 保存成功后，异步保存到mysql中（rocketmq或redis list）

```
local n = tonumber(ARGV[1])
if not n or n == 0 then
  return 0
end
local val = redis.call("hmget", KEYS[1], "total", "selled");
local total = tonumber(val[1]);
local selled = tonumber(val[2]);
if not total or not selled then
  return -1
end
if selled + n <= total then
  redis.call("hincrby", KEYS[1], "selled", n);
  return n;
end
return -2;
```

#### 秒杀系统设计

1. 隔离：业务隔离，需要提前预约才能抢购；数据库隔离；机房隔离，容器隔离
2. （可选）设计抢购前填写验证码，实现流量削峰
3. 浏览器缓存、CDN缓存。动静分离，静态数据保存在浏览器和CDN中，动态数据请求后端
4. Nginx，缓存
5. 分流，设计多个服务，服务压力均摊
6. 限流、熔断、降级
7. 后端接口
   1. 缓存预热：提前按照商品维度设计库存量和已售卖量，保存在redis中
   2. 秒杀请求
      1. 通过redis+lua扣减缓存，若当前售卖量信息为空（目前仅当redis宕机才可能出现为空的情况），则读取数据库获得最新数据（此时数据库数据量肯定大于最新redis量，因为可能还有部分请求仍在队列中，未更新到数据库）
      2. 查询数据库时，添加分布式互斥锁，再次查询缓存，不存在再查询数据库（添加共享锁），获得数据后放入缓存中
      3. 若当前售卖量信息不为空但扣减失败，直接返回秒杀失败
      4. 若redis扣减库存成功，则发送mq消息，异步实现数据库库存扣减及订单生成
      5. 幂等校验，判断该用户是否已经秒杀过该商品（redis缓存+数据库唯一键约束），若秒杀过则直接返回秒杀失败，回调通知秒杀结果
      6. 数据库扣减数据，创建订单数据（幂等专用），若数据库无可扣减库存，则返回秒杀失败；若数据库出现网络、数据库等异常，消息延迟重试处理；若扣减成功，则回调通知秒杀成功

### 幂等设计

#### 本地消息表

![img](../image/dedup-solution-02.png)

### 如何保证数据库与缓存的一致性

参考：https://juejin.cn/post/6844903941646319623

数据数据库和缓存，就只能保证最终一致性，强一致性几乎不可能

#### 1. 缓存的读取和更新

读取：首先查询缓存，存在直接返回；若不存在则查询数据库获取最新数据，保存到缓存中，然后返回

更新：当数据库发生变更时，缓存如何更新

- 先更新缓存，再更新数据库：不可行。很可能存在缓存更新成功数据库更新失败
- 先删除缓存，再更新数据库：不可行。1.A删除缓存；2.B查询缓存，不存在则设置缓存；3.A更新数据库。可能造成导致缓存与数据库不一致
- 先更新数据库，再更新缓存：不可行。1.A更新数据库；2.B更新数据库；3.B更新缓存；4.A更新缓存。可能造成缓存与数据库不一致
- 先更新数据库，再更新缓存：基本可行。1. 无缓存，A查询数据库；2.B更新数据库；3.B删除缓存；4.A更新缓存。可能存在不一致性，但这种情况可能性很低，数据库查询一般较快（不过快照读会增加这种情况的概率）。然而在主从分离的情况下，发生这种情况的概率更高

问题分析：先更新后删除策略，可能删除缓存会失败，而这样直接回滚数据库也不合理。这里可以通过重试多次的方式保证缓存更新成功，然后可能引入消息队列的方式，注意同一个缓存应保证顺序（可以配置kafka或rocketmq相同的sharding key），尽量减少失败的概率，但因重试会导致更长时间的缓存与数据不一致

#### 2. binlog同步

因缓存更新引入消息队列这些过于麻烦，直接通过订阅binlog日志来实现缓存删除策略，异步解耦。binlog订阅的master节点，也没办法解决上述主从同步的数据库不一致问题

#### 3. 强一致性思路

要达到强一致性，就需要解决数据库更新至缓存更新这段数据不一致的时间问题。时间差必然存在，可以通过控制这段时间不允许缓存读取，即阻塞读请求。引入分布式读写锁，写入时添加写锁，阻塞读请求或者只能读数据库，保证不会读到脏数据，但是分布式读写锁的实现和问题也不少，而且阻塞的读请求直接数据库可能导致数据库压力过大...

#### 4. 缓存击穿

缓存更新时可能存在某时刻缓存删除，大量请求打入，直击数据库导致数据库宕机。此时可以通过加锁的方式，当缓存不存在，添加锁，只允许一个请求访问数据库获得最新结果，放入缓存中。单机直接使用互斥锁，机器量大需要使用分布式锁，高并发下分布式锁实现也比较有考验

**总结**：分布式系统下，往往只能保证数据的最终一致性，若无法容忍短暂的不一致性，就需要通过其他更复杂的方式实现，系统复杂度飙升

### 接口加解密

sign：签名。对明文数据字符串A进行base64得到字符串B，在B后添加MD5-KEY得到字符串C，再进行md5得到sign

Data：数据。对明文数据字符串A进行base64得到字符串B，再使用秘钥AES-KEY进行AES加密得到密文data

### 优化点

1. hibernate遇到第一个错误即返回失败，不必校验全部错误
2. 分库分表，库表数量为2的整数次幂，在分表时直接使用&位运算

