### 如何保证数据库与缓存的一致性

参考：https://juejin.cn/post/6844903941646319623

数据数据库和缓存，就只能保证最终一致性，强一致性几乎不可能

#### 1. 缓存的读取和更新

读取：首先查询缓存，存在直接返回；若不存在则查询数据库获取最新数据，保存到缓存中，然后返回

更新：当数据库发生变更时，缓存如何更新

- 先更新缓存，再更新数据库：不可行。很可能存在缓存更新成功数据库更新失败
- 先删除缓存，再更新数据库：不可行。1.A删除缓存；2.B查询缓存，不存在则设置缓存；3.A更新数据库。可能造成导致缓存与数据库不一致
- 先更新数据库，再更新缓存：不可行。1.A更新数据库；2.B更新数据库；3.B更新缓存；4.A更新缓存。可能造成缓存与数据库不一致
- 先更新数据库，再更新缓存：基本可行。1. 无缓存，A查询数据库；2.B更新数据库；3.B删除缓存；4.A更新缓存。可能存在不一致性，但这种情况可能性很低，数据库查询一般较快（不过快照读会增加这种情况的概率）。然而在主从分离的情况下，发生这种情况的概率更高

问题分析：先更新后删除策略，可能删除缓存会失败，而这样直接回滚数据库也不合理。这里可以通过重试多次的方式保证缓存更新成功，然后可能引入消息队列的方式，注意同一个缓存应保证顺序（可以配置kafka或rocketmq相同的sharding key），尽量减少失败的概率，但因重试会导致更长时间的缓存与数据不一致

#### 2. binlog同步

因缓存更新引入消息队列这些过于麻烦，直接通过订阅binlog日志来实现缓存删除策略，异步解耦。binlog订阅的master节点，也没办法解决上述主从同步的数据库不一致问题

#### 3. 强一致性思路

要达到强一致性，就需要解决数据库更新至缓存更新这段数据不一致的时间问题。时间差必然存在，可以通过控制这段时间不允许缓存读取，即阻塞读请求。引入分布式读写锁，写入时添加写锁，阻塞读请求或者只能读数据库，保证不会读到脏数据，但是分布式读写锁的实现和问题也不少，而且阻塞的读请求直接数据库可能导致数据库压力过大...

#### 4. 缓存击穿

缓存更新时可能存在某时刻缓存删除，大量请求打入，直击数据库导致数据库宕机。此时可以通过加锁的方式，当缓存不存在，添加锁，只允许一个请求访问数据库获得最新结果，放入缓存中。单机直接使用互斥锁，机器量大需要使用分布式锁，高并发下分布式锁实现也比较有考验

**总结**：分布式系统下，往往只能保证数据的最终一致性，若无法容忍短暂的不一致性，就需要通过其他更复杂的方式实现，系统复杂度飙升

