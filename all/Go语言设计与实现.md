## 二、编译原理

## 三、数据结构

### 3.1 数组

数据包含类型和长度两种属性，二者均相同的数组才是同种类型数组，能相互赋值

**初始化**

```
arr1 := [3]int{1,2,3}
arr2 := [...]int{1,2,3}
```

上面两种声明方式得到的数组都是[3]int，[...]int会根据元素个数动态

> 在不考虑逃逸分析的情况下，如果数组元素个数小于等于4，那所有的变量直接在栈上初始化；若大于4，则现在静态存储区初始化，然后拷贝到栈上
>
> todo
>
> 1. 学习go的存储区域
> 2. 了解go的逃逸分析

### 3.2 切片

切片的组成

- Data：指向数组的指针。指向的地址是一片连续的内存空间
- Len：切片的实际长度
- Cap：切片的容量，即Data数组的大小

```go
arr1 := [3]int{1,2,3}
var arr2 []int
// arr2 = arr1	// 编译错误
arr2 = arr1[:]	// 通过[:]可构造一个切片，获取数组的全部元素
```

切片最终在堆上初始化

### 3.3 哈希表

哈希表：拥有优秀读写性能的K-V表

哈希冲突：不管使用什么样的哈希函数，保存数据的时候都会使得多个数据命中在一个桶上，造成哈希冲突。解决哈希冲突常用的方法有开放寻址法和拉链法解决

**解决哈希冲突的方法**

开放寻址法：当向哈希表写入数据产生冲突时，就将键值对写入到下一个索引不为空的位置。读取时候也是，先通过哈希函数算出索引位置，比对key是否相等，若不相等则后移一位比较，直至找到key或索引为空为止

拉链法：把索引当成一条链表，当产生冲突时往链表后追加元素，往往也会通过红黑树替代链表来优化读写性能

#### 读写操作

**删除**

delete(hash, key)  删除map中的key

**扩容**

哈希表的每个桶只能存储8个键值对，当超过8个时就会存储在溢出桶中。随着溢出桶和负载因子的增加（负载因子=实际总数量/桶*8），超过阈值时开始扩容，扩容将桶数量翻倍且非原子的，扩容期间访问哈希表会使用旧桶，写入时也会触发旧桶元素的分流



### 3.4 字符串

string 字符串保存在一片连续的只读内存中，不支持修改。修改字符串是通过转化为[]char来实现修改的

**数据结构**

```go
type StringHeader struct {
  Data uintptr	// 数据指针
  Len int	// 长度
}
```



**解析过程**

```
str1 := "\"hello go\""
str2 := `"hello go"`	// 反引号内不需要斜杠协助解析引号
```







